<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Million dollar, baby !</title>

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        body {
            padding: 0;
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        button {
            background: rgb(80, 50, 100);
            border: 1px solid transparent;            
            border-radius: 0;
            color: white;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
        }

        button:disabled {
            background: rgb(100, 80, 100);
            color: rgb(180, 180, 180);
            cursor: auto;
        }

        .modal {
            position: absolute;
            z-index: 1000;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 20, 50, 0.8);
            display: flex;
        }

        .modal .content {
            margin: auto;
        }

        .modal span {
            color: white;
        }

        .sidebar {
            z-index: 2;
            position: absolute;
            left: -200px;
            width: 230px;
            height: 100%;
            display: flex;
            transition: left 1s ease;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar .content {
            border-right: 5px solid rgba(20, 20, 50, 0.2);
            height: 100%;
            width: 200px;
            background: white;
        }

        .sidebar .content > * {
            padding-left: 10px;
            padding-right: 10px;
        }

        .sidebar .hotspot {
            height: 100%;
            width: 20px;
            margin: 5px;
            cursor: pointer;
            writing-mode: vertical-lr;
            text-orientation: sideways-left;
            text-align: center;
            text-shadow: 0 0 5px rgb(80, 50, 100);
        }

        .sidebar .bottom {
            position: absolute;
            bottom: 0px;
            width: 175px;
            background: white;
        }

        .sidebar .bottom * {
            width: 175px;
            margin-bottom: 10px;
        }

        li.highlight {
            text-decoration-line: underline;
        }

        .background {
            position: absolute;
            z-index: 1;
            width: 100%;
            height: 100%;
            left: 0;
        }
    </style>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css"/>

    <script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
</head>
<body>
    <div id="enter-modal" class="modal">
        <div class="content">
                <span>Enter</span>
                <input id="room-input" type="text" placeholder="Room name..." />
                <span>as</span>
                <input id="player-input" type="text" placeholder="Player name..." />
                <button id="enter-button">OK</button>
        </div>
    </div>

    <div id="menu-sidebar" class="sidebar">
        <div class="content">
            <p>Room: <span id="room-name"></span></p>
            <p>Players:</p>
            <div>
                <ul id="player-list">
                    <li id="player-me" class="highlight"></li>
                </ul>
            </div>

            <div class="bottom">
                <button id="area-button">Select area</button>
                <button id="start-button" disabled>OK</button>
            </div>
        </div>
        <p id="menu-hotspot" class="hotspot">Tap to toggle menu</p>
    </div>

    <div id="map-background" class="background">
        <div class="leaflet-bottom leaflet-right">
                <canvas id="myCanvas" width="150" height="450"></canvas>
        </div>
            
    </div>

    <script>
        'use strict'

        /**********************************************************************
        * VARIABLES
        **********************************************************************/
        
        var Lyon_coord = [45.771774, 4.845743];
        var area_circle_radius = 3500; // meters


        // ---- Next circle ---- //
        var nb_next_circle = 3;
        var distance_between_next_circles = 100; // meter
        var next_circle_prop_smaller = 0.7;
		var const_meter_lat_lng = 111230;
        var EARTH_RADIUS = 6371;

        // ---- Timer ---- //
        var timer_id = "myCanvas";

        var time_interval = 0.1; // sec
        var time_to_next_zone = 5; // sec
        var time_pause = 10; // sec
        var str_timer_value;
        
        var counter_nb_next_circle = 0;


        
        var width_canvas = 200 // px
        var height_canvas = 100 // px
        var width_rect_timer = 150 // px
        var height_rect_timer = 100 // px


        /**********************************************************************
        * FUNCTION
        **********************************************************************/
        
        // Transform second in hours, minutes and seconds //
        String.prototype.toHHMMSS = function () {
            var sec_num = parseInt(this, 10);
            var hours   = Math.floor(sec_num / 3600);
            var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
            var seconds = sec_num - (hours * 3600) - (minutes * 60);

            if (hours   < 10) {hours   = "0"+hours;}
            if (minutes < 10) {minutes = "0"+minutes;}
            if (seconds < 10) {seconds = "0"+seconds;}
            return hours+':'+minutes+':'+seconds;
        }

        // function loadTimer() {
        //     var c = document.getElementById(timer_id);
        //     var ctx = c.getContext("2d");
            
        //     // Parameters //
        //     ctx.font = "20px Arial";
        //     ctx.fillStyle="white";
        //     ctx.fillRect(0,0,width_rect_timer, height_rect_timer);
        //     ctx.fillStyle="black";

        // // if (counter_time_step < nb_time_step-1) {
        //     timer_value = timer_value -time_interval; // sec
        //     //console.log('timer_value', timer_value);
        //     str_timer_value = timer_value.toString();
        // //     counter_time_step += 1;
        // // }
        //     ctx.fillText(str_timer_value.toHHMMSS(),0,80);
        // }

        function find_next_circle(coords_area_circle, radius_area_circle, coords_previous_circle, radius_previous_circle) {
			var new_radius_next_circle = radius_previous_circle *next_circle_prop_smaller; 
            var b = radius_area_circle -new_radius_next_circle; // radius of circle area where will be the center of the next_cirle < circle_area
            //var new_radius_next_circle = 50; 
            //var b = 150 -new_radius_next_circle; // radius of circle area where will be the center of the next_cirle < circle_area
            
            // Distance between next_circle and the following //
            distance_between_next_circles += distance_between_next_circles *next_circle_prop_smaller; 
            //distance_between_next_circles = 40; 

            // Check that distance_between_next_circles is still in the circle area // 
            var c = distance_between_next_circles;
            if (c > b){
                c = b;
                distance_between_next_circles = b;
            } 

            // Init params in while loop //
            var counter_loop = 0;
            var next_center_outside_area = true;
            var max_counter_loop = 100;
            var coord_temp; 

            // Loop to find solution at the intersection of the circle and the area //
            while (next_center_outside_area && counter_loop < max_counter_loop){
                var deg = getRandomArbitrary(0,360);
                coord_temp = getPoint(coords_previous_circle.lat, coords_previous_circle.lng, c, deg);
                //console.log('coord_temp',coord_temp);
                
                var dist = getDistance_between_2_coord([coords_area_circle.lat, coords_area_circle.lng], [coord_temp.lat, coord_temp.lng])
                //console.log('dist', counter_loop)
                if (dist < b){
                    next_center_outside_area = false;
                }
                counter_loop += 1;
            }
        return {coords: coord_temp, radius: new_radius_next_circle}

        }
				
		function getPoint(lat, lng, r, deg) {
            let lat2 = meter_to_lat_lng(r) * Math.cos(deg2rad(deg));
            lat2 += lat;
            let lng2 = meter_to_lat_lng(r) * Math.sin(deg2rad(deg));
            lng2 = lng2 * (1 / Math.cos(deg2rad(lat2)));
            lng2 += lng;
            return {lat:lat2, lng:lng2};
            }

        function getDistance_between_2_coord(origin, destination) {
            // return distance in meters
            var lon1 = deg2rad(origin[1]),
                lat1 = deg2rad(origin[0]),
                lon2 = deg2rad(destination[1]),
                lat2 = deg2rad(destination[0]);

            var deltaLat = lat2 - lat1;
            var deltaLon = lon2 - lon1;

            var a = Math.pow(Math.sin(deltaLat/2), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(deltaLon/2), 2);
            var c = 2 * Math.asin(Math.sqrt(a));
            return c * EARTH_RADIUS * 1000;
            }

        // function dist_to_lat_or_lon(meter_dist){
        //     lat_or_lon = meter_dist/(1000*EARTH_RADIUS);
        //     return rad2deg(lat_or_lon);
        //     }

        function meter_to_lat_lng(meter){
            return meter/const_meter_lat_lng;
            }

        function deg2rad(deg) {
            return deg * (Math.PI / 180);
            }
            
        function rad2deg(rad) {
            return rad * (180/Math.PI);
            }
            
        function getRandomArbitrary(min, max) {
            return Math.random() * (max - min) + min;
            }

        function sec_to_ms(time_sec) {
            return time_sec *1e3;
            }

        function nb_time_step_func(time, time_interval) {
            return Math.floor(time/time_interval);
        }

        /**********************************************************************
         *
         * React-like application components
         *
         * Each component manages parts of the DOM via function calls.
         * The DOM is seen as the single point of truth, components
         * have no internal state.
         *
         *********************************************************************/

        const mdbRoom = (() => {
            const _span = document.getElementById('room-name');

            this.get = () => { return _span.innerText; };

            this.set = name => { _span.innerText = name; };

            return this;
        })();

        const mdbPlayers = (() => {
            const _ul = document.getElementById('player-list');
            const _li = document.getElementById('player-me');

            this.list = () => {
                let l = [];
                let nodes = _ul.getElementsByTagName('li');
                for (let li of nodes) { l.push(li.innerText); }
                return l;
            };

            this.add = (player, isMe) => {
                if (isMe) { _li.innerText = player }
                else { _ul.innerHTML += '<li>' + player + '</li>'; }
            };

            this.me = () => { return _li.innerText; };
            
            return this;
        })();

        const mdbMasterControl = (() => {
            const start_button = document.getElementById('start-button');
            const area_button = document.getElementById('area-button');

            // rate at which the eye of the cyclones decreases
            const _rate = 0.8;

            // Test if player is master //
            this.isMaster = () => { 
                return !area_button.disabled || !start_button.disabled;
                // TODO or eye selection is enabled on map
            };

            this.enableNextMove = () => {
                area_button.disabled = true;
                mdbMap.enableEyeSelection(() => {
                    start_button.disabled = false;
                });
            };

            this.confirmNextMove = () => {
                start_button.disabled = true;
                area_button.disabled = true; // TODO or not?
                mdbMap.disableEyeSelection();
            };

            // Withdraw master control to (non-master) player //
            this.disable = () => { 
                start_button.disabled = true;
                area_button.disabled = true;
            };

            // computes random coordinates s.t. 
            // r_i = 0.8 * r_{i-1} and
            // area_i strictly in area_{i-1} 
            this.pickMove = (previousMove) => {
                // no next move below 1m radius
                if (previousMove.radius < 1) return null;

                let polar = {
                    r: Math.random() * (1 - _rate) / 2 * previousMove.radius,
                    theta: Math.random() * 2 * Math.PI
                };
                let cartesian = {
                    x: polar.r * Math.cos(polar.theta),
                    y: polar.r * Math.sin(polar.theta)
                };
                let c = [
                    previousMove.coords[0] + (cartesian.y / 360000),
                    previousMove.coords[1] + (cartesian.x / 360000)
                ];
                let r = _rate * previousMove.radius;

                return { coords: c, radius: r };
            };

            return this;
        })();

        const mdbMap = (() => {
            const _m = L.map('map-background');
            // ssssssh. Don't tell.
            const _token = 'pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpej' +
                           'Y4NXVycTA2emYycXBndHRqcmZ3N3gifQ.' +
                           'rJcFIG214AriISLbB6B5aw';
            // markers on the map indexed by player name (eye indexed by _eye)
            const _markers = {};

            const _style = {
                eye: { color: '#909090', fillOpacity: 0.2, dashArray: '10px' },
                next_circle_area: { color: '#503264', fillOpacity: 0.2, dashArray: '10px' },
                player: { color: '#503264' },
                error: { color: '#dd2222' }
                // TODO out-of-the-game
            };

            let uri = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png' +
                      '?access_token=' + _token;
            let layer = L.tileLayer(uri, {
                maxZoom: 19,
                // TODO CC license attributions
                id: 'mapbox.streets'
            });
            _m.addLayer(layer);
            // Lyon, tavu
            _m.setView(Lyon_coord, 14);

            this.next_circle_area = (coords, radius) => {
                let position = coords;
                let e = _markers._next_circle_area;
                    // If circle is undefined //
                    if (!e) {
                        let opts = Object.create(_style.next_circle_area);
                        opts.radius = radius;
                        e = L.circle(position, opts).addTo(_m);
                        _markers._next_circle_area = e;
                        }
                        
                    // Actualize position and radius //
                    e.setLatLng(position);
                    e.setRadius(radius);
            };

            this.getEye = () => {
                let e = _markers._eye;
                if (e) {
                    return {
                        coords: e.getLatLng(),
                        radius: e.getRadius()
                    };
                } else {
                    return null;
                }
            };

            // a callback can be provided, called
            // whenever a new eye has been selected
            this.enableEyeSelection = (cb) => {
                _m.on('click', ev => {
                    moveEye(ev.latlng, area_circle_radius);
                    cb();
                });
            };

            this.disableEyeSelection = () => {
                _m.off('click');
            }

            this.moveEye = (coords, radius) => {
                let e = _markers._eye;
                if (!e) {
                    let opts = Object.create(_style.eye);
                    opts.radius = radius;
                    e = L.circle(coords, opts).addTo(_m);
                    _markers._eye = e;
                }
                e.setLatLng(coords);
                e.setRadius(radius);
            };

            this.move = (player, coords) => {
                let m = _markers[player];
                if (!m) {
                    let opts = _style.player;
                    m = L.circleMarker(coords, opts)
                            .bindPopup(player.toString()) // Popup player's name onclick
                            .addTo(_m);
                    _markers[player] = m;
                } else if (m.frozen) {
                    m.frozen = undefined;
                    m.setStyle(_style.player);
                }
                m.setLatLng(coords);
            };

            this.freeze = player => {
                let m = _markers[player];
                if (m) {
                    m.setStyle(_style.error);
                    m.frozen = true;
                }
            };

            this.center = coords => { _m.setView(coords); };

            return this;
        })();

        const mdbTimer = (() => {

            this.decrease_timer = () => {
                var c = document.getElementById(timer_id);
                var ctx = c.getContext("2d");
                
                var counter_time_step = 0;
                var nb_time_step;
                var timer_type = "game";
                var timer_value = time_to_next_zone;

                let id = window.setInterval(() => {
                
                    if (timer_value > 2*time_interval) { // 2*time_interval to prevent bad approximation near zero
                        // Timer //
                        timer_value = timer_value -time_interval; // sec
                        str_timer_value = timer_value.toString();

                        // Parameters //
                        ctx.font = "20px Arial";
                        ctx.fillStyle="white";
                        ctx.fillRect(0,0,width_rect_timer, height_rect_timer);
                        ctx.fillStyle="black";
                        ctx.fillText(str_timer_value.toHHMMSS(),0,80);        
                    } 
                    
                    else if (timer_value <= 2*time_interval && timer_type == "game") {
                        timer_value = time_pause;
                        timer_type = "pause";
                    }

                    else {
                        window.clearInterval(id);
                    }
                }, sec_to_ms(time_interval));

            };

            return this;
        })();


        /**********************************************************************
         *
         * UI and application events
         *
         *********************************************************************/

        const allEvents = [
            // a player/master enters the room
            'mdbEnter',
            // master recalls the list of players present in the room
            'mdbRecallPresent',
            // a player moves on the map
            'mdbMove',
            // the location of a player has been lost
            'mdbMoveError',
            // the game engine moves the eye of the cyclone
            'mdbMoveEye',
            // Next circle area
            'mdbNextCircle',
            // Load timer
            // 'mdbLoadTimer',
            // Position player in the area
            'mdbOut'
        ];

        window.addEventListener('mdbEnter', ev => {
            // If a player join a room already created //
            if (ev.detail.player != mdbPlayers.me()) {
                if (mdbMasterControl.isMaster()) {
                    let otherEv = new CustomEvent('mdbRecallPresent', {
                        detail: { present: mdbPlayers.list() }
                    });
                    window.dispatchEvent(otherEv);
                }
                
                mdbPlayers.add(ev.detail.player, false);
            } 
            // If it is the first player in the room: the master //
            else {
                let id = navigator.geolocation.watchPosition(pos => {
                    let p = mdbPlayers.me();
                    let coords = [pos.coords.latitude, pos.coords.longitude];

                    let d = { detail: { player: p, coords: coords } };
                    window.dispatchEvent(new CustomEvent('mdbMove', d));
                }, (err) => {
                    let p = mdbPlayers.me();
                    let d = { detail: { player: p }};
                    window.dispatchEvent(new CustomEvent('mdbMoveError', d));
                    
                    console.error(err.message);
                });
            }
        });

        window.addEventListener('mdbRecallPresent', ev => {
            // TODO manage page reloading (duplicate entries/no entry)
            if (!ev.detail.present.includes(mdbPlayers.me())) {
                mdbMasterControl.disable();
                ev.detail.present.forEach(p => mdbPlayers.add(p, false));
            }
        }, { once: true });

        window.addEventListener('mdbMove', ev => {
            let p = ev.detail.player;
            let coords = ev.detail.coords;
            mdbMap.move(p, coords);

            if (p == mdbPlayers.me()) {
                mdbMap.center(coords);
            }          
        });

        window.addEventListener('mdbMoveError', ev => {
            let p = ev.detail.player;
            mdbMap.freeze(p);
        });

        window.addEventListener('mdbMoveEye', ev => {
            let m = ev.detail.move;
            mdbMap.moveEye(m.coords, m.radius);
        });

        window.addEventListener('mdbNextCircle', ev => {
            let m = ev.detail;
            mdbMap.next_circle_area(m.params.coords, m.params.radius);
            mdbTimer.decrease_timer();


            
            // if ( < ) {
                
            //     console.log('caca', timer_value);
            // }
        });

        // window.addEventListener('mdbLoadTimer', ev => {
        //     let m = ev.detail;
        //     mdbMap.loadTimer();
        //         });

        window.addEventListener('mdbOut', ev => {
            let p = ev.detail.player;
            let coords = ev.detail.coords;

            // // Test distance to next circle or circle area //
            // let markers_on_map;
            // console.log('lol', markers_on_map)
            // if (markers_on_map._next_circle_area){
            //     let dist_temp = getDistance_between_2_coord(coords, [markers_on_map._next_circle_area.getLatLng().lat, markers_on_map._next_circle_area.getLatLng().lng]);
            //     console.log('prout', dist_temp, markers_on_map._next_circle_area.getRadius());
            //     if (dist_temp > markers_on_map._next_circle_area.getRadius()) {
            //         console.log('pipi', dist_temp);
            //     }
            // }
            // else if (markers_on_map._area_circle){
            //     let dist_temp = getDistance_between_2_coord(coords, [markers_on_map._area_circle.getLatLng().lat, markers_on_map._area_circle.getLatLng().lng]);
            //     console.log('prout', dist_temp, markers_on_map._area_circle.getRadius());
            //     if (dist_temp > markers_on_map._area_circle.getRadius()) {
            //         console.log('caca', dist_temp);
            //     }
            // }

        //     if ( != mdbPlayers.me()) {
        //         if (mdbMasterControl.isMaster()) {
        //             let otherEv = new CustomEvent('mdbRecallPresent', {
        //                 detail: { present: mdbPlayers.list() }
        //             });
        //             window.dispatchEvent(otherEv);
        //         }
                
        //         mdbPlayers.add(ev.detail.player, false);
        //     } 
        //     // If it is the first player in the room: the master //
        //     else {
        //         mdbMasterControl.ButtonsStatusMaster() // Adjust buttons status
        //         let id = navigator.geolocation.watchPosition(pos => {
        //             let p = mdbPlayers.me();
        //             let coords = [pos.coords.latitude, pos.coords.longitude];

        //             let d = { detail: { player: p, coords: coords } };
        //             window.dispatchEvent(new CustomEvent('mdbMove', d));
        //         }, (err) => {
        //             let p = mdbPlayers.me();
        //             let d = { detail: { player: p }};
        //             window.dispatchEvent(new CustomEvent('mdbMoveError', d));
                    
        //             console.error(err.message);
        //         });
        //     }
        });





        document.getElementById('enter-button').onclick = ev => {
            let pi = document.getElementById('player-input'),
                ri = document.getElementById('room-input'),
                em = document.getElementById('enter-modal'),
                rn = document.getElementById('room-name');

            // TODO normalize input (e.g. no '_')
            let room = ri.value;
            let me = pi.value;
            mdbRoom.set(room);
            mdbPlayers.add(me, true);
            
            window.dispatchEvent(new CustomEvent('mqttSubscribe'));
            let d = { detail: { player: me } };
            window.dispatchEvent(new CustomEvent('mdbEnter', d));

            // close modal
            em.parentElement.removeChild(em);
        };

        // ---- Create/change circular zone on click ---- //
        document.getElementById('area-button').onclick = ev => {
            mdbMasterControl.enableNextMove();
        };

        document.getElementById('start-button').onclick = ev => {
            mdbMasterControl.confirmNextMove();

            // Get coords area_circle //
            let e = mdbMap.getEye();
            let coords_area_circle = e.coords;
            let radius_area_circle = e.radius;
            let coords_previous_circle = coords_area_circle;
            let radius_previous_circle = radius_area_circle;

            var array_next_circle = []; // Init

            // Generate next circle serie //
            var i;
            for (i = 0; i < nb_next_circle; i++) {

                let new_next_circle = find_next_circle(coords_area_circle, radius_area_circle, coords_previous_circle, radius_previous_circle);
                array_next_circle[i] = {coords: new_next_circle.coords, radius: new_next_circle.radius}
                
                coords_previous_circle = new_next_circle.coords;
                radius_previous_circle = new_next_circle.radius;
            }            

            // Set Timer //
            // var timer_type = "next_zone";
            // var counter_time_step = 0;
            // var counter_nb_next_circle = 0;
            // timer_value = mdbTimer.time_to_next_zone;
            // var nb_time_step = nb_time_step_func(timer_value, time_interval);

            // Create next_circle area //
            let d_circle = { detail: {params : array_next_circle[counter_nb_next_circle]}};
            window.dispatchEvent(new CustomEvent('mdbNextCircle', d_circle));

            // let id = window.setInterval(() => {
                
            //     if (counter_time_step < nb_time_step -1) {
            //         // Timer //
            //         counter_time_step += 1;
            //         // let d_timer = { detail: { param: counter_time_step } };
            //         // window.dispatchEvent(new CustomEvent('mdbLoadTimer', d_timer));
            //     } 

            //     else if (counter_time_step >= nb_time_step -1 && counter_nb_next_circle < nb_next_circle -1) {
            //         counter_time_step = 0; // Re-init

            //         // Set Timer //
            //         if (timer_type == "next_zone"){                        
            //             timer_type = "pause"
            //             timer_value = time_pause;
            //             nb_time_step = nb_time_step_func(timer_value, time_interval)
                        
            //             // Check position of each player //
            //             let d = { detail: { coords: Lyon_coord } };
            //             window.dispatchEvent(new CustomEvent('mdbOut', d));
            //             // let id = navigator.geolocation.watchPosition(pos => {
            //             //     let p = mdbPlayers.me();
            //             //     let coords = [pos.coords.latitude, pos.coords.longitude];
                        
            //             //     let d = { detail: { player: p, coords: coords } };
            //             //     window.dispatchEvent(new CustomEvent('mdbOut', d));
            //             // }, (err) => {
            //             //     let p = mdbPlayers.me();
            //             //     let d = { detail: { player: p }};
            //             //     window.dispatchEvent(new CustomEvent('mdbMoveError', d));
                            
            //             //     console.error(err.message);
            //             // });
            //         }

            //         else if (timer_type == "pause"){
            //             counter_nb_next_circle += 1;

            //             timer_type = "next_zone"
            //             timer_value = time_to_next_zone;
            //             nb_time_step = nb_time_step_func(timer_value, time_interval)

            //             // Change next_circle area //
            //             let d_circle = { detail: {params : array_next_circle[counter_nb_next_circle], counter_time_step: counter_time_step, nb_time_step: nb_time_step }};
            //             window.dispatchEvent(new CustomEvent('mdbNextCircle', d_circle));

            //         }
            //     }

            //     else {
            //         window.clearInterval(id);
            //     }
            // }, sec_to_ms(time_interval));

        };

        document.getElementById('menu-hotspot').onclick = ev => {
            let classes = document.getElementById('menu-sidebar').classList;
            // toggle menu
            if (classes.contains('open')) {
                classes.remove('open');
            } else {
                classes.add('open');
            }
        };

        /**********************************************************************
         *
         * MQTT client
         *
         * Proxy between all players that transforms MQTT messages
         * into events dispatched via the window object.
         *
         *********************************************************************/

        // per-window identification to avoid pub/sub loops
        const mqttId = Math.random();
         // MQTT topic for the room
        const mdbTopic = () => { return 'oasisisgood/mdb/' + mdbRoom.get(); }

        // TODO potential endpoints:
        //  + ws://iot.eclipse.org:80/ws
        //  - ws://test.mosquitto.org:8080
        //  - wss://iot.eclipse.org:443/ws
        //  - ws://test.mosca.io/
        //  - ws://q.emqtt.com:8083
        //  - ws://mqtt.flespi.io:80
        //  - ws://broker.hivemq.com:8000
        //  - ws://mqtt.dioty.co:8080
        //  - ws://mqtt.fluux.io
        let mqttClient = mqtt.connect('ws://iot.eclipse.org:80/ws'); // TODO wss
        mqttClient.on('connect', function() { console.log('connected'); });

        mqttClient.on('message', (topic, msg) => {
            console.log('>> (MQTT) ' + topic + ' | ' + msg.toString());
            
            let ev = JSON.parse(msg);

            if (topic === mdbTopic() && ev.detail.from != mqttId) {
                window.dispatchEvent(new CustomEvent(ev.type, { detail: ev.detail }));

                console.log('<< (DOM) ' + ev.type + ' | ' + JSON.stringify(ev.detail));
            }
        });

        allEvents.forEach(type => {
            window.addEventListener(type, ev => {
                console.log('>> (DOM) ' + ev.type + ' | ' + JSON.stringify(ev.detail));

                if (!ev.detail.from) {
                    ev = { type: ev.type, detail: ev.detail }; // copy
                    ev.detail.from = mqttId;
                    let msg = JSON.stringify(ev);
    
                    let topic = mdbTopic();                
                    mqttClient.publish(topic, msg, function(err) {
                        if (err) console.error(err);
                    });
        
                    console.log('<< (MQTT) ' + topic + ' | ' + msg);
                }
            });
        });

        window.addEventListener('mqttSubscribe', ev => {
            mqttClient.subscribe(mdbTopic(), err => {
                if (err) console.error(err);
            });
        });
    </script>
</body>
</html>